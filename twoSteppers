#include <Servo.h>
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"

Servo pen;
Adafruit_MotorShield AFMS = Adafruit_MotorShield(); 
Adafruit_StepperMotor *rotationMotor = AFMS.getStepper(200, 2); // Rotate
Adafruit_StepperMotor *elevationMotor = AFMS.getStepper(200, 1); // Elevate


// rotation range: 0 - 200 (wrap around)
// elevation range: 0 - 200 (no wrap around)
double x_calibration = 1;
double y_calibration = 1;
int x_step = 1;
int y_step = 4;
int pen_down = 125;
int pen_up = 180;

int azimuth = 0;
int elevation = 0;

void setup() {
  Serial.begin(9600);
  Serial.println("Starting!");
  delay(2000);
  pen.attach(9);

  AFMS.begin();  // create with the default frequency 1.6KHz
}

void loop() {  

  drawBezier(14, 46, 13, 60, 53, 85, 68, 48);
  Serial.print("loc is at (");
  Serial.print(azimuth);
  Serial.print(",");
  Serial.print(elevation);
  Serial.println(")");
  
  drawRect(0, 100, 20, 20);
  drawRect(50, 120, 20, 20);
}

void adjustPen(bool draw) {
  int offset = 6;
  if (!draw) {
    pen.write(180);
    return;
  }
  if (elevation < 30) {
    pen.write(128 + offset);
  }
  else if (elevation < 50) {
    pen.write(132 + offset);
  }
  else if (elevation < 70) {
    pen.write(135);
  }
  else if (elevation < 100) {
    pen.write(140);
  }
  else if (elevation < 130) {
    pen.write(134);
  }
  else {
    pen.write(127);
  }
}


void moveTo(int startx, int starty) {
  if (azimuth == startx && elevation == starty) {
    return;
  }
  drawLine(azimuth, elevation, startx, starty, false);
}


// startx, starty, endx, endy
// use this but set "bool draw" to false if you just want to move between points but not draw
void drawLine(int startx, int starty, int endx, int endy, bool draw) {  
  moveTo(startx, starty);
  
  if (startx == endx) {
    // vertical line
    if (endy > starty) {
      for (int y = starty; y < endy; y += y_calibration) {
        elevationMotor->step(y_step, FORWARD, SINGLE);
        elevation += 1;
        adjustPen(draw);
      }
    }
    else {
      for (int y = starty; y > endy; y -= y_calibration) {
        elevationMotor->step(y_step, BACKWARD, SINGLE);
        elevation -= 1;
        adjustPen(draw);
      }
    }
  }

  else {
    double slope = (1.0 * endy - starty) / (1.0 * endx - startx);
    double intercept = slope * -startx + starty; 
    double last_x = 0.0;
    double last_y = 0.0;

    for (double t = 0.0; t <= 1.0; t += 0.0001) {
      double x = (endx - startx) * t;
      double y = slope * x + intercept;

      if ((x - last_x) > x_calibration) {
        rotationMotor->step(x_step, FORWARD, SINGLE);
        last_x = x;
        azimuth++;
      }
      else if ((last_x - x) > x_calibration) {
        rotationMotor->step(x_step, BACKWARD, SINGLE);
        last_x = x;
        azimuth--;
      }
      if ((y - last_y) > y_calibration) {
        elevationMotor->step(y_step, FORWARD, SINGLE);
        last_y = y;
        elevation++;
        adjustPen(draw);
      }
      else if ((last_y - y) > y_calibration) {
        elevationMotor->step(y_step, BACKWARD, SINGLE);
        last_y = y;
        elevation--;
        adjustPen(draw);
      }
    }
  }
  azimuth = endx;
  elevation = endy;
}


void drawRect(int cx, int cy, int width, int height) {
  Serial.println("Drawing Rect");
  moveTo(cx, cy);
  drawLine(cx, cy, cx + width, cy, true);
  drawLine(cx + width, cy, cx + width, cy + height, true);
  drawLine(cx + width, cy + height, cx, cy + height, true);
  drawLine(cx, cy + height, cx, cy, true);
}

void drawBezier(int p0x, int p0y, int p1x, int p1y, int p2x, int p2y, int p3x, int p3y) {
  Serial.println("Drawing Bezier");
  moveTo(p0x, p0y);
  adjustPen(true);
  
  double last_x = 0.0;
  double last_y = 0.0;
  for (double t = 0.0; t <= 1.0; t += 0.0001) {
    double x = pow((1.0-t),3)*p0x + 3*t*pow((1.0-t), 2)*p1x + 3*pow(t,2)*(1-t)*p2x + pow(t,3) * p3x;
    double y = pow((1.0-t),3)*p0y + 3*t*pow((1.0-t), 2)*p1y + 3*pow(t,2)*(1-t)*p2y + pow(t,3) * p3y;
    if ((x - last_x) > x_calibration) {
      rotationMotor->step(x_step, FORWARD, SINGLE);
      last_x = x;
      azimuth++;
    }
    else if ((last_x - x) > x_calibration) {
      rotationMotor->step(x_step, BACKWARD, SINGLE);
      last_x = x;
      azimuth--;
    }
    if ((y - last_y) > y_calibration) {
      elevationMotor->step(y_step, FORWARD, SINGLE);
      last_y = y;
      elevation += y_step;
      adjustPen(true);
    }
    else if ((last_y - y) > y_calibration) {
      elevationMotor->step(y_step, BACKWARD, SINGLE);
      last_y = y;
      elevation -= y_step;
      adjustPen(true);
    }
    azimuth = p3x;
    elevation = p3y + 5;
    // this  "fixes" rounding errors
  }
}
