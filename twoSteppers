#include <Servo.h>
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"

Servo pen;
Adafruit_MotorShield AFMS = Adafruit_MotorShield(); 
Adafruit_StepperMotor *rotationMotor = AFMS.getStepper(200, 2); // Rotate
Adafruit_StepperMotor *elevationMotor = AFMS.getStepper(200, 1); // Elevate


// rotation range: 0 - 200 (wrap around)
// elevation range: 0 - 200 (no wrap around)
double x_calibration = 1;
double y_calibration = 1;
int x_step = 1;
int y_step = 4;
int pen_down = 125;
int pen_up = 180;
double elevation = 0.0;

void setup() {
  Serial.begin(9600);
  pen.attach(9);

  AFMS.begin();  // create with the default frequency 1.6KHz
}

//servo middle:55
void loop() {
  Serial.println("got here");
  /*movePenDown();
  delay(3000);
  movePenUp();
  delay(3000);*/
  for (int i = 130; i <= 150; i += 5) {
    pen.write(i);
    Serial.println(i);
    delay(3000);
  }
  //pen.write(140);
  // draw line
  //drawLine(0, 0, 50, 50, false);
  //drawLine(50, 50, 0, 0, false);
  //drawRect(0, 0, 200, 200);
  //movePenDown();
  //delay(2000);
  //movePenUp();
  //delay(5000);
  // heart
  
  //drawBezier(0, 0, 94, 143, 48, 75, 157, 284);
  delay(3000);
  /*drawBezier(157, 358, 265, 358, 354, 460, 354, 460);
  delay(1000);
  drawBezier(354, 461, 354, 460, 391, 372, 480, 369);
  delay(1000);
  drawBezier(480, 369, 568, 366, 494, 678, 357, 746);
  delay(3000);*/
}


void movePenDown() {
  pen.write(pen_down);
}

void movePenUp() {
  pen.write(pen_up);
}

void adjustPen() {
  
  pen.write(elevation);
}

// startx, starty, endx, endy
// use this but set "bool draw" to false if you just want to move between points but not draw
void drawLine(int startx, int starty, int endx, int endy, bool draw) {
 
  //draw ? movePenDown() : movePenUp();
  
  if (startx == endx) {
    // vertical line
    if (endy > starty) {
      for (int y = starty; y < endy; y += y_calibration) {
        elevationMotor->step(y_step, FORWARD, SINGLE);
        elevation += 1;
        Serial.println(elevation);
      }
    }
    else {
      for (int y = starty; y > endy; y -= y_calibration) {
        elevationMotor->step(y_step, BACKWARD, SINGLE);
        elevation -= 1;
        Serial.println(elevation);
      }
    }
  }

  else {
    double slope = (endy - starty) / (endx - startx);
    double intercept = -startx * slope + starty; 
    double last_x = 0.0;
    double last_y = 0.0;

    for (double t = 0; t < 1; t += 0.001) {
      double x = (endx - startx) * t;
      double y = slope * x + intercept;

      if ((x - last_x) > x_calibration) {
        rotationMotor->step(1, FORWARD, SINGLE);
        last_x = x;
      }
      else if ((last_x - x) > x_calibration) {
        rotationMotor->step(1, BACKWARD, SINGLE);
        last_x = x;
      }
      if ((y - last_y) > y_calibration) {
        elevationMotor->step(y_step, FORWARD, SINGLE);
        last_y = y;
        elevation += 1;
        Serial.println(elevation);
      }
      else if ((last_y - y) > y_calibration) {
        elevationMotor->step(y_step, BACKWARD, SINGLE);
        last_y = y;
        elevation -= 1;
        Serial.println(elevation);
      }
    }
  }
}


void drawRect(int cx, int cy, int width, int height) {
  Serial.println("Drawing Rect");
  drawLine(cx, cy, cx + width, cy, true);
  drawLine(cx + width, cy, cx + width, cy + height, true);
  drawLine(cx + width, cy + height, cx, cy + height, true);
  drawLine(cx, cy + height, cx, cy, true);
}

void drawBezier(int p0x, int p0y, int p1x, int p1y, int p2x, int p2y, int p3x, int p3y) {
  Serial.println("Drawing Bezier");
  double last_x = 0.0;
  double last_y = 0.0;
  for (double t = 0; t < 1.0; t += 0.001) {
    double x = pow((1-t),3)*p0x + 3*t*pow((1-t), 2)*p1x + 3*pow(t,2)*(1-t)*p2x + pow(t,3) * p3x;
    double y = pow((1-t),3)*p0y + 3*t*pow((1-t), 2)*p1y + 3*pow(t,2)*(1-t)*p2y + pow(t,3) * p3y;
    if ((x - last_x) > x_calibration) {
      rotationMotor->step(x_step, FORWARD, SINGLE);
      last_x = x;
    }
    else if ((last_x - x) > x_calibration) {
      rotationMotor->step(x_step, BACKWARD, SINGLE);
      last_x = x;
    }
    if ((y - last_y) > y_calibration) {
      elevationMotor->step(y_step, FORWARD, SINGLE);
      last_y = y;
      elevation += y_step;
    }
    else if ((last_y - y) > y_calibration) {
      elevationMotor->step(y_step, BACKWARD, SINGLE);
      last_y = y;
      elevation -= y_step;
    }
  }
}
